# Vue 笔记

## 1.2 初识 Vue

- 初识 Vue 1. 想让 Vue 工作，就必须创建一个 Vue 实例，且要传入一个配置对象；

  2. root 容器里的代码依然符合 html 规范，只不过混入了一些特殊的 Vue 语法；

  3. root 容器里的代码被称为【Vue 模板】；

  4. Vue 实例和容器是一一对应的；

  5. 真实开发中只有一个 Vue 实例，并且会配合着组件一起使用；

  6. {{xxx}}中的 xxx 要写 js 表达式，且 xxx 可以自动读取到 data 中的所有属性；

  7. 一旦 data 中的数据发生改变，那么页面中用到该数据的地方也会自动更新；

- 注意区分：js 表达式 和 js 代码(语句) 1. 表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：

```python
    (1). a
    (2). a+b
    (3). demo(1)
    (4). x === y ? 'a' : 'b'
```

​ 2. js 代码(语句)

```python
    (1). if(){}
    (2). for(){}
```

## 1.3 模板语法

- data 与 el 的 2 种写法
  1. el 有 2 种写法
     (1). new Vue 时候配置 el 属性。
     (2).先创建 Vue 实例，随后再通过 vm.$mount('#root')指定 el 的值。
  2. data 有 2 种写法
     (1).对象式
     (2).函数式
     如何选择：目前哪种写法都可以，以后学习到组件时，data 必须使用函数式，否则会报错。
  3. 一个重要的原则：
     由 Vue 管理的函数，一定不要写箭头函数，一旦写了箭头函数，this 就不再是 Vue 实例了。

## 1.4 数据绑定

- Vue 中有 2 种数据绑定的方式：

  1. 单向绑定(v-bind)：数据只能从 data 流向页面。

  2. 双向绑定(v-model)：数据不仅能从 data 流向页面，还可以从页面流向 data。

- 备注：

  ​ _1. 双向绑定一般都应用在表单类元素上（如：input、select 等）_
  ​ _2. v-model:value 可以简写为 v-model，因为 v-model 默认收集的就是 value 值。_

## 1.5 MVVM 模型

1. M：模型(Model) ：data 中的数据
2. V：视图(View) ：模板代码
3. VM：视图模型(ViewModel)：Vue 实例

观察发现：
1.data 中所有的属性，最后都出现在了 vm 身上。
2.vm 身上所有的属性 及 Vue 原型上所有属性，在 Vue 模板中都可以直接使用。

## 1.5\* 数据代理

### 1.5\*.1 回顾 Object.defineProperty 方法

- enumerable:true, //控制属性是否可以枚举，默认值是 false
- writable:true, //控制属性是否可以被修改，默认值是 false
- configurable:true //控制属性是否可以被删除，默认值是 false

## 1.6 事件处理

### 1.6.1 绑定监听

事件的基本使用：

1. 使用 v-on:xxx 或 @xxx 绑定事件，其中 xxx 是事件名；
2. 事件的回调需要配置在 methods 对象中，最终会在 vm 上；
3. methods 中配置的函数，不要用箭头函数！否则 this 就不是 vm 了；
4. methods 中配置的函数，都是被 Vue 所管理的函数，this 的指向是 vm 或 组件实例对象；
5. @click="demo" 和 @click="demo($event)" 效果一致，但后者可以传参；

### 1.6.2 事件修饰符

Vue 中的事件修饰符：

1. prevent：阻止默认事件（常用）；
2. stop：阻止事件冒泡（常用）；
3. once：事件只触发一次（常用）；
4. capture：使用事件的捕获模式；
5. self：只有 event.target 是当前操作的元素时才触发事件；
6. passive：事件的默认行为立即执行，无需等待事件回调执行完毕；

### 1.6.3 按键修饰符

1. Vue 中常用的按键别名：
   回车 => enter
   删除 => delete (捕获“删除”和“退格”键)
   退出 => esc
   空格 => space
   换行 => tab (特殊，必须配合 keydown 去使用)
   上 => up
   下 => down
   左 => left
   右 => right

2.Vue 未提供别名的按键，可以使用按键原始的 key 值去绑定，但注意要转为 kebab-case（短横线命名） 3.系统修饰键（用法特殊）：ctrl、alt、shift、meta
(1).配合 keyup 使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。
(2).配合 keydown 使用：正常触发事件。

4.也可以使用 keyCode 去指定具体的按键（不推荐）
5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名

## 1.7 计算属性与监视

**计算属性：** 1. 定义：要用的属性不存在，要通过已有属性计算得来。 2. 原理：底层借助了 Objcet.defineproperty 方法提供的 getter 和 setter。 3. get 函数什么时候执行？
(1).初次读取时会执行一次。
(2).当依赖的数据发生改变时会被再次调用。 4. 优势：与 methods 实现相比，内部有缓存机制（复用），效率更高，调试方便。 5. 备注： 1.计算属性最终会出现在 vm 上，直接读取使用即可。 2.如果计算属性要被修改，那必须写 set 函数去响应修改，且 set 中要引起计算时依赖的数据发生改变。

**监视属性 watch：** 1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作 2.监视的属性必须存在，才能进行监视！！ 3.监视的两种写法：
(1).new Vue 时传入 watch 配置
(2).通过 vm.$watch 监视

**深度监视：**
(1).Vue 中的 watch 默认不监测对象内部值的改变（一层）。
(2).配置 deep:true 可以监测对象内部值改变（多层）。
备注：
(1).Vue 自身可以监测对象内部值的改变，但 Vue 提供的 watch 默认不可以！
(2).使用 watch 时根据数据的具体结构，决定是否采用深度监视。

## 1.8 class 与 style 绑定

**绑定样式：** 1. class 样式
写法
:class="xxx" xxx 可以是字符串、对象、数组。
字符串写法适用于：类名不确定，要动态获取。
对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。
数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。 2. style 样式
:style="{fontSize: xxx}"其中 xxx 是动态值。注意是 fontSize 不是 font-size
:style="[a,b]"其中 a、b 是样式对象。

## 1.9 条件渲染

1.v-if
写法：
(1).v-if="表达式"
(2).v-else-if="表达式"
(3).v-else="表达式"
适用于：切换频率较低的场景。
特点：不展示的 DOM 元素直接被移除。
注意：v-if 可以和:v-else-if、v-else 一起使用，但要求结构不能被“打断”。

2.v-show
写法：v-show="表达式"
适用于：切换频率较高的场景。
特点：不展示的 DOM 元素未被移除，仅仅是使用样式隐藏掉

3.备注：使用 v-if 的时，元素可能无法获取到，而使用 v-show 一定可以获取到。

## 1.10 条件渲染

### 1.10.1 基本列表

v-for 指令:  
1.用于展示列表数据  
2.语法：v-for="(item, index) in xxx" :key="yyy"  
3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）

### 1.10.2 key 的原理

面试题：react、vue 中的 key 有什么作用？（key 的内部原理）

1. 虚拟 DOM 中 key 的作用：
   key 是虚拟 DOM 对象的标识，当数据发生变化时，Vue 会根据【新数据】生成【新的虚拟 DOM】,
   随后 Vue 进行【新虚拟 DOM】与【旧虚拟 DOM】的差异比较，比较规则如下：

2.对比规则：
(1).旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key：
①.若虚拟 DOM 中内容没变, 直接使用之前的真实 DOM！
②.若虚拟 DOM 中内容变了, 则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM。

              (2).旧虚拟DOM中未找到与新虚拟DOM相同的key
                          创建新的真实DOM，随后渲染到到页面。

3. 用 index 作为 key 可能会引发的问题： 1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:
    会产生没有必要的真实 DOM 更新 ==> 界面效果没问题, 但效率低。

                    2. 如果结构中还包含输入类的DOM：
                                    会产生错误DOM更新 ==> 界面有问题。

4. 开发中如何选择 key?: 1.最好使用每条数据的唯一标识作为 key, 比如 id、手机号、身份证号、学号等唯一值。 2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，
    使用 index 作为 key 是没有问题的。

### 1.10.8 Vue.set 的使用

- Vue.set( target, propertyName/index, value )  
  参数：
  {Object | Array} target  
  {string | number} propertyName/index  
  {any} value  
  返回值：设置的值。

用法：  
向响应式对象中添加一个 property，  
并确保这个新 property 同样是响应式的，且触发视图更新。  
它必须用于向响应式对象上添加新 property，  
因为 Vue 无法探测普通的新增 property  
(比如 this.myObject.newProperty = 'hi')  
注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。

- vm.$set( target, propertyName/index, value )
  这是全局 Vue.set 的别名。

### 1.10.10 总结数据监视

      Vue监视数据的原理：
       1. vue会监视data中所有层次的数据。

       2. 如何监测对象中的数据？
           通过setter实现监视，且要在new Vue时就传入要监测的数据。
            (1).对象中后追加的属性，Vue默认不做响应式处理
            (2).如需给后添加的属性做响应式，请使用如下API：
                Vue.set(target，propertyName/index，value) 或
                vm.$set(target，propertyName/index，value)

       3. 如何监测数组中的数据？
            通过包裹数组更新元素的方法实现，本质就是做了两件事：
             (1).调用原生对应的方法对数组进行更新。
             (2).重新解析模板，进而更新页面。

       4.在Vue修改数组中的某个元素一定要用如下方法：
          1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()
          2.Vue.set() 或 vm.$set()

       特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！

## 1.11 收集表单数据

收集表单数据：
    若：<input type="text"/>，则v-model收集的是value值，用户输入的就是value值。
    若：<input type="radio"/>，则v-model收集的是value值，且要给标签配置value值。
    若：<input type="checkbox"/>
        1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）
        2.配置input的value属性:
            (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）
            (2)v-model的初始值是数组，那么收集的的就是value组成的数组
    备注：v-model的三个修饰符：
            lazy：失去焦点再收集数据
            number：输入字符串转为有效的数字
            trim：输入首尾空格过滤

## 1.12 过滤器

过滤器：
  定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。
  语法：
    1.注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}
    2.使用过滤器：{{ xxx | 过滤器名}}  或  v-bind:属性 = "xxx | 过滤器名"
  备注：
    1.过滤器也可以接收额外参数、多个过滤器也可以串联
    2.并没有改变原本的数据, 是产生新的对应的数据

## 1.13 内置指令与自定义指令

我们学过的指令：
  v-bind : 单向绑定解析表达式, 可简写为 :xxx
  v-model : 双向数据绑定
  v-for   : 遍历数组/对象/字符串
  v-on    : 绑定事件监听, 可简写为@
  v-if    : 条件渲染（动态控制节点是否存存在）
  v-else  : 条件渲染（动态控制节点是否存存在）
  v-show  : 条件渲染 (动态控制节点是否展示)

### 1.13.1 v-text_指令

v-text指令：
  1.作用：向其所在的节点中渲染文本内容。
  2.与插值语法的区别：v-text会替换掉节点中的内容，{{xx}}则不会。

### 1.13.2 v-html_指令

v-html指令：
  1.作用：向指定节点中渲染包含html结构的内容。
  2.与插值语法的区别：
      (1).v-html会替换掉节点中所有的内容，{{xx}}则不会。
      (2).v-html可以识别html结构。
  3.严重注意：v-html有安全性问题！！！！
      (1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。
      (2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！

### 1.13.3  v-cloak_指令

 v-cloak指令（没有值）：
      1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。
      2.使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题。

### 1.13.4  v-once指令

   v-once指令：
      1.v-once所在节点在初次动态渲染后，就视为静态内容了。
      2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。

### 1.13.5  v-pre指令

   v-pre指令：
     1.跳过其所在节点的编译过程。
     2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。

### 1.13.6  自定义指令

需求1：定义一个v-big指令，和v-text功能类似，但会把绑定的数值放大10倍。
    需求2：定义一个v-fbind指令，和v-bind功能类似，但可以让其所绑定的input元素默认获取焦点。
    自定义指令总结：
      一、定义语法：
         (1).局部指令：
            new Vue({               new Vue({
             directives:{指令名:配置对象}   或     directives{指令名:回调函数}
            })                   })
         (2).全局指令：
             Vue.directive(指令名,配置对象) 或   Vue.directive(指令名,回调函数)

            指令钩子函数会被传入以下参数：

            el：指令所绑定的元素，可以用来直接操作 DOM。
            binding：一个对象，包含以下 property：
                name：指令名，不包括 v- 前缀。
                value：指令的绑定值，例如：v-my-directive="1 + 1" 中，绑定值为 2。
                oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。
                expression：字符串形式的指令表达式。例如 v-my-directive="1 + 1" 中，表达式为 "1 + 1"。
                arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 "foo"。
                modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。

      二、配置对象中常用的3个回调：
         (1).bind：指令与元素成功绑定时调用。
         (2).inserted：指令所在元素被插入页面时调用。
         (3).update：指令所在模板结构被重新解析时调用。

      三、备注：
         1.指令定义时不加v-，但使用时要加v-；
         2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。

## 1.14 Vue 实例生命周期

### 1.14.1 引出生命周期

 生命周期：
      1.又名：生命周期回调函数、生命周期函数、生命周期钩子。
      2.是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。
      3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。
      4.生命周期函数中的this指向是vm 或 组件实例对象。

### 1.14.2 分析生命周期

      四大阶段，八大方法

   阶段  方法名   方法名
   初始化  beforeCreate created
   挂载  beforeMount  mounted
   更新  beforeUpdate updated
   销毁  beforeDestroy destroyed

### 1.14.3 总结生命周期
    - 常用的生命周期钩子：
      1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。
      2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。

    - 关于销毁Vue实例
      1.销毁后借助Vue开发者工具看不到任何信息。
      2.销毁后自定义事件会失效，但原生DOM事件依然有效。
      3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。
